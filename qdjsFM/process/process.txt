Как теперь должен работать updater

1 Вместо lsh и ls должен теперь работать только inotifyd.				*
  Не надо запускать их при старте.										*
  
  inotifyd будет запускать updater и только при необходимости.
2 Получив список изменений, он проходит по списку файлов.
   для удаленного 
    проверяет, отображается ли он сейчас
     удаляет из отображений, перестраивает по сути всё.
      А лучше добавляет следующий.
    удаляет из списка в памяти
   для измененного
    выполняет ls file обновляет данные.
   для нового
    вставляет в список согласно текущей сортировке.
    определяет, надо ли изменить список отображеиня.

-------------
бязательно проверь на хеше 6014bc8df27363b6fec676874b88c1495491b816
на слабой машине в win/sy32
Кажется, всё-таки стало лучше...

Надо 
	 рендеринг файлов партиями (проверить сначала на /lib на слабой машине)		*
	 Статус свободного места в разделе доделать за счет обращения к devices		*
	 скрытые  файлы
	  - пункт в меню															*
	  - его адекватная поддержка в html5										*
	  - его адекватная поддержка в Qt (научить переименовывать меню).			*
	  - Добавить в документацию описание и задеплоить							*
	  - Скомпилировать для 32													*
	 Борьба с утечкой памяти													*
	  - Добавить DaemonMaster													*
	  - Заменить рендеринг списка файлов через демон							*
		- демон считывает нужный каталог из файла								*
		- пишет в файл daemonName.out список, 									*
			но первой строчкой BOF нужный каталог								*
			последней EOF нужный каталог										*
		
	 грамотный рефреш (не перерисовывать всё целиком)
	  - выделение несколько свойств												*
	  - Если выделить правой клавишей, не убирается левой						*
	  - При переименовании в другом проводнике
			выделенным не остается если сменился порядок
	  - для списка без скрытых													*
	  - для списка со скрытыми				
	 оживить статус.
	 оживить табы
	 Сортировка
	 Установка ширины секций в списке (не должны выходить за экран как сейчас на 1024 * 768)
	 доделать и оживить контекстное меню файлов									(...)
		Копирование.
		 Имеем атрибут n который кажется позволит скопировать без перезатирания все, которых нет в целевом.
		 Но, если мы в фоне запустим с -n, а сами начнем вычислять, какие файлы надо заменить,
		  это приведет к тому, что увидим сообщение о перезаписи касающееся только что скопированных файлов.
		 То есть мимо.
		 
		 Нужно перебрать все исходные и проверить, не перезаписываем ли.
		 Как тогда ускорить?
			- Если в каталоге назначения файла нет, сразу копируем (ещё при подсчёте).
		 Что такое большой файл (который надо мониторить по байтам для прогрессбара)?
		    - Берем 1Мб как маленький. Всё что больше мониторим, если скопировался быстрее чем за секунду, значит повышаем планку 1Мб.
	     Всё это в отдельном проекте, чтобы меньше памяти кушать.
	     То есть, диалог, который запускаем.
	     А помня о слабой машине, видимо это демон.	     
	     Ясно, что запускается.
	     Неясно, как коммуницировать.
	     Например, пишем в файл
	     команда
	     целевой каталог
	     файл_или_каталог_1
	     файл_или_каталог_2
	     файл_или_каталог_3
	     Чтобы такого не было проблем, принял команду и тут же стер её из файла.
	     Данные из файла пишем в объект.
	     Если пришла новая, создаем новый объект.
	     Операции по объектам есть смысл проводить, давая слово им по очереди (вдруг второй объект содержит данные малых файлов).
	     Проводник не пишет в слот, если он не пуст.
	     
	     1 Создать пустой демон. Пусть просто выводит данные из файла slot.				*
	     2 Обеспечить его запуск при старте.											*
	     3 При выборе пункта км копировать копируем в буфер пути, в память тоже их.		*
			Апдейтер на паузу перед копированием.										*
	     4 При выборе пункта км вставить копируем путь целевого каталога и пишем его в 	*
			слот с учетом правила														*
	       "проводник не пишет в файл, если он не пуст (существует?)."					*
	     
	 доделать и оживить контекстное меню области, в которой лежат файлы
	  извлечение из архива
	 создать и оживить контекстное меню закладок
	 создать и оживить контекстное меню устройств
		монтирование и размонтирование
	 поиск в каталоге при наборе
	 
	 


А потом можно переходить к struct.txt (если надо)


