Наследник ColorRuleBase
обязательно должен либо не перегружать 
ColorRuleBase::calc
либо сохранить при перегрузке вызов

ColorRule.context.setRules(rules);

Например
class ColorRuleSql extends ColorRuleBase
{
	// Если пришлось перегрузить calc
	calc(sValue) {
		// .... здесь какая-то логика
		
		// этот вызов должен быть обязательно
		this.context.setRules(aRules);
		
		
		
		// // aRules: [sCssClassName, undefined, sOtherCssClassName, ... ]
		
		// И тут лучше всё-таки диапазоны использовать, чтобы меньше памяти расходовать
		
		// // aRules: {
			'kw'/*this.cssKeyword*/: [0,5, 7, 10] // с 0 по 5  и с 7 по 10 стилизовать классом kw
		}
		
		// И при проверке тогда:
		// Если i входит в один из диапазонов комментариев, вернем 'c'
		// Иначе, если i входит в один из диапазонов строк, вернем 's' или 'ss'
		// Иначе, если i входит в один из диапазонов ключевых слов вернем 'kw'
		// Иначе, если i входит в один из диапазонов регулярных выражений вернем 'r'
		// Иначе, если i входит в один из диапазонов числовых констант вернем 'n'
	}
}


В целом, наследники ColorRuleBase скорее всего будут просто переопределять списки ключевых слов.

check* функции в базовом классе детектят комментарии и строки для языка с C++ подобным синтаксисом
И регулярки для js

